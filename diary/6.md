# Day 4

Yesterday I tried to create a dummy client do connect to the dummy server, but it was late in the night, so I'm only writting today. It had a lot of bugs, which I'm fixing now.

My first idea is: the game has a few independent parts, the start menu, the multiplayer game and the singleplayer game. There should also be a configuration section, but not for now. So we would have a enum like this.

```c
enum GameSegment
{
	START_MENU,
	MULTIPLAYER,
	SINGLEPLAYER,
	NONE,
};
```

NONE segment means the game should end.

And from main, we would call a procedure like `game_start_menu_handle()` or `game_multiplayer_handle()`, but there is a problem: each segment handler would have to handle WindowShouldClose() or something like that. So I created a few files for the client.

	main.c
	singleplayer.c
	multiplayer.c
	start_menu.c

The main.c looks like this:

```c
#include <stdlib.h>
#include <stdio.h>

#include "raylib.h"

#include "client/game.h"
#include "./start_menu.c"
#include "./multiplayer.c"
#include "./singleplayer.c"

int
main
(void)
{
	InitWindow(500, 500, "Bonk.c");
	SetTargetFPS(60);

	struct Game game = {0};
	enum GameSegment segment = START_MENU;

	while (segment != NONE)
	{
		switch (segment)
		{
			case START_MENU:
				segment = game_start_menu_handle();
				break;
			case MULTIPLAYER:
				segment = game_multiplayer_handle(&game);
				break;
			case SINGLEPLAYER:
				segment = game_singleplayer_handle(&game);
				break;
			case NONE:
				break;
		}
	}

	return EXIT_SUCCESS;
}
```

The singleplayer and start menu handlers are simple for now, they just show a text on screen, because the focus is the multiplayer part. The file multiplayer.c has the function game_multiplayer_handle(), that initiates a loop that runs game_network_update() until the networking state is DISCONNECTING. In that case, it disconnects and returns to the start menu.

```c
#include "client/game.h"
#include "./network.c"

static inline
enum GameSegment
game_multiplayer_handle
(struct Game *game)
{
	printf("Starting multiplayer.\n");

	while (!WindowShouldClose() && game->networking.state != DISCONNECTING)
	{
		if (!game_network_update(game))
		{ game->networking.state = DISCONNECTING; }
	}

	enet_peer_reset(game->networking.server);
	enet_host_destroy(game->networking.client);
	printf("ENetHost client destroyed.\n");

	return START_MENU;
}
```

I put game_network_update() in a separate file, network.c. It's composed by two switches:

 - The first handles the networking state. If it's CONNECTING, it calls game_network_connect(), and returns failure if so does the function. If it's CONNECTED, it asks for an immediate event by calling enet_host_service(). In case it's DISCONNECTING or DISCONNECTED, it just returns false, because it will break the parent loop, and the parent function will take care of actually disconnecting.

 - The second switch handles the event got by its type.

```c
static inline
bool
game_network_update
(struct Game *game)
{
	switch (game->networking.state)
	{
		case CONNECTING:
			// Wait longer
			if (!game_network_connect(&game->networking))
			{ return false; }
			else { game->networking.state = CONNECTED; }
			break;
		case CONNECTED:
			enet_host_service(game->networking.client, &game->networking.event, 0);
			break;
		case DISCONNECTING:
		case DISCONNECTED:
			return false;
			break;
	}

	switch (game->networking.event.type)
	{
		case ENET_EVENT_TYPE_CONNECT:
			break;
		case ENET_EVENT_TYPE_DISCONNECT:
			return false;
			break;
		case ENET_EVENT_TYPE_RECEIVE:
			break;
		case ENET_EVENT_TYPE_NONE:
			break;
	}
	return true;
}
```

One thing that is unsettling me is that ENET_EVENT_TYPE_CONNECT is "treated" in two different places. Here, in game_network_update(), but also when we try to connect to the server, in game_network_connect(). I shall resolve this later.

```c
static inline
bool
game_network_connect
(struct GameNetworking *networking)
{
	enet_initialize();

	// Create client ENetHost

	networking->client = enet_host_create(NULL, 1, 2, 0, 0);
	if (networking->client == NULL)
	{
		fprintf(stderr, "Failed to initialize client ENetHost.\n");
		return false;
	}
	else
	{ printf("Initialized client ENetHost.\n"); }

	// Connect to server peer

	enet_address_set_host(&networking->address, "127.0.0.1");
	networking->address.port = 1234;

	networking->server = enet_host_connect(networking->client, &networking->address, 2, 0);
	if (networking->server == NULL)
	{
		fprintf(stderr, "Server peer isn't avaiavble for initiating an ENet connection.\n");
		return false;
	}

	// Wait for a connect event at server

	if
	(
		enet_host_service(networking->client, &networking->event, 5000) > 0
		&& networking->event.type == ENET_EVENT_TYPE_CONNECT
	)
	{
		puts("Connection to server succeeded.\n");
		return true;
	}

	enet_peer_reset(networking->server);
	fprintf(stderr, "Connection to server failed. No connect event got.\n");
	return false;
}
```

Anyway, it does compiles, and if I start the server in background and the game later, and press M to enter the multiplayer segment, the client apparently acknoeldges the server.

	Starting multiplayer.
	Initialized client ENetHost.
	Connection to server succeeded.

	Player connected.

However, the CPU usage increases to 100%, which probably means a problem in some loop running wild.

Also, when I press M and enter the multiplayer, there is no way to escape, besides pressing Ctrl+C to kill the process in the terminal. Maybe that's because the game_multiplayer_handle() doesn't takes input, but it's loop has a !WindowShouldClose() condition, which would technically stop the handle and return to main menu on Esc, for example.