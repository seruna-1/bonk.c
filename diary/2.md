# Day 2

Approximately 10:00, just created meson.build file. Now going to start server and client.

After some reading, I made the server like this:

```c
#include <enet/enet.h>
#include <stdio.h>

const int max_players = 32;

int
main
(void)
{
	if (enet_initialize() != 0)
	{
		fprintf(stderr, "Failed to initialize enet.\n");
		return EXIT_FAILURE;
	}

	ENetAddress address = { .host = ENET_HOST_ANY, .port = 1234 };

	ENetHost *server = enet_host_create(&address, max_players, 2, 0, 0);
	if (server == NULL)
	{
		fprintf(stderr, "Failed to initialize server.\n");
		return EXIT_FAILURE;
	}

	printf("Server started on port %d.\n", address.port);

	enet_host_destroy(server);
	printf("Enet host destroyed.\n");

	return EXIT_SUCCESS;
}
```

It compiles and runs.

	[mateus@lenovo bonk.c]$ ninja -C build/
	[mateus@lenovo bonk.c]$ ./build/server
	Server started on port 1234.
	Enet host destroyed.

I was unsure about the third parameter passed to enet_host_create(). It is the limit of channels to use. For now, I let it be 2, one channel for client sending input to server, and another channel for server sending location data to client.

Now we need to listen for enet events, like connection and disconnection of clients.

In the main function:

```c
	bool keep_server_running = true;
	while (keep_server_running)
	{
		ENetEvent event = { 0 };

		if (enet_host_service(server, &event, 1000) > 0)
		{ server_handle_network_event(event); }
	}
```

Then I created some static inline functions.

```c
static inline
void
server_handle_network_event_connection
(void)
{
	printf("Player connected.\n");
}

static inline
void
server_handle_network_event_disconnection
(void)
{
	printf("Player disconnected.\n");
}

static inline
void
server_handle_network_event_stillness
(void)
{
	return;
}

static inline
void
server_handle_network_event_reception
(void)
{
	return;
}

static inline
void
server_handle_network_event
(ENetEvent event)
{
	switch (event.type)
	{
		case ENET_EVENT_TYPE_CONNECT:
			server_handle_network_event_connection();
			break;

		case ENET_EVENT_TYPE_DISCONNECT:
			server_handle_network_event_disconnection();
			break;

		case ENET_EVENT_TYPE_RECEIVE:
			server_handle_network_event_reception();
			break;

		case ENET_EVENT_TYPE_NONE:
			server_handle_network_event_stillness();
			break;
	}
}
```

Functions handling reception and stillness would be called a lot of times per second, so I avoided putting printf calls inside them.

Now, time code the client to connect to this dummy server.